act_comm.c:	    //remove_from_all_lboards( ch->name);
act_comm.c:    char *url=strstr(argument, "http://");
act_comm.c:    // show group
act_comm.c:        // show group members in room first to ensure same targeting order as for other commands
act_comm.c:        // afterwards pick up all group members not in room
act_comm.c:    // remove from group
act_comm.c:    // pass on leadership
act_comm.c:    // add to group
act_comm.c:        // show syntax
act_comm.c:        //send_to_char( "They aren't here.\n\r", ch );
act_comm.c:            //nt_act_new( "{3$n{3 tells the group {4'$t'{x", ch, argument, gch, TO_VICT, POS_SLEEPING );
act_comm.c:			//sprintf(buf, "{3%s{3 tells the group {4'%s'{x\n\r", get_mimic_PERS_new( ch, gch, 0), argument );
act_info.c:        // added so that objects (i.e. glowing ones) are shown 
act_info.c:	    // added so that objects (i.e. glowing ones) are shown 
act_info.c:                // color-code spells about to expire
act_info.c:// for sorting the who_array
act_info.c:    // high-level characters go first
act_info.c:    // same for clan rank - higher ranks first
act_info.c:    // gather all characters we want to show
act_info.c:    // now sort it
act_info.c:        // translucent eq has "hidden" ops
act_info.c:	return; // prevent easy learning by spamming sage
act_info.c:        // generate string for bar graph
act_info.c:                    // red color
act_info.c:        // terminate string
act_info.c:        // now send it to output
act_info.c:// show offhand attack and other percentages
act_info.c:    // secondary and two-handed weapons
act_info.c:    // dodge, parry, block
act_info.c:        //send_to_char(buf, ch);
act_info.c:        //send_to_char(buf, ch);
act_info.c:	current=0;//so numbers don't carry over from previous loops
act_info.c:		//bug message here
act_info.c:        //send_to_char("Achievement unlocked -- TEST.\n\r",ch);
act_info.c:	//this later
act_info.c:  // all good, let's do it
act_info.c:        // calculate number and cost of skills
act_info.c:        // list details
act_move.c:    // guilds and clan halls
act_move.c:    // should never reach this point
act_move.c:    // movement cost and lag
act_move.c:        // climbing
act_move.c:	    //act( "$p isn't jammed(?)", ch, obj, NULL, TO_CHAR );
act_move.c:    // misgate chance when cursed but not normally
act_move.c:    af.type      = gsn_entrapment; // need SOME skill..
act_move.c:	int mask = vnum / 32; //Get which bucket the bit is in
act_move.c:	int bit = vnum % 32; //Get which bit to set, 0 to 31
act_move.c:	EXPLORE_HOLDER *pExp; //The buckets bucket.
act_move.c:	for(pExp = ch->pcdata->explored->buckets ; pExp ; pExp = pExp->next ) //Iterate through the buckets
act_move.c:		//Found the right bucket, might be explored.
act_move.c:		return FALSE; //Return immediately. This value wont be in any other bucket.
act_move.c://Explore a vnum. Assume it's not explored and just set it.
act_move.c:{	int mask = vnum / 32; //Get which bucket it will be in
act_move.c:	int bit = vnum % 32; // Get which bit to set, 0 to 31
act_move.c:	EXPLORE_HOLDER *pExp; //The buckets bucket.
act_move.c:	//Find the bucket.
act_move.c:	if(!pExp) //If it's null, bucket not found, we'll whip one up.
act_move.c:		pExp = (EXPLORE_HOLDER *)calloc(sizeof(*pExp), 1); //Alloc and zero
act_move.c:		pExp->next = ch->pcdata->explored->buckets; //Add to
act_move.c:		ch->pcdata->explored->buckets = pExp;       //the list
act_move.c:	ch->pcdata->explored->set++; //Tell how many rooms we've explored
act_move.c://Explore a vnum.
act_move.c://This shows all the rooms they've explored. Probably don't need mortals seeing this, and for immortals... it'd get really spammy. Mostly an example.
act_move.c://RUN COMMAND by SIVA 2/14/04
act_move.c:	//local variables
act_move.c:	char *p;	//pointer to iterate argument
act_move.c:	int i; //counter for for loops
act_move.c:	int last = 0; //holds last character of argument
act_move.c:	int par_counter = 0; // for turning chars into ints	
act_move.c:	//Not for the pkillers! (change this if flag is different)
act_move.c:	//add similar check to prevent use during warfare!
act_move.c:	//add similar check to prevent use during freeze tag!
act_move.c:	//do we have valid string of input?
act_move.c:	//make sure argument is valid
act_move.c:			} //end switch
act_move.c:		} //end for loop
act_move.c:	//If last character of argument is a number, that doesn't work either!
act_move.c:	//reset number parser for actual movements
act_move.c:	//execute the run movements
act_move.c:		//make a number from the string
act_move.c:				//check for aggro mobs, can't run past them!
act_move.c:					} //end of aggro for
act_move.c:				} //end of for
act_move.c:	} //end of big for
act_move.c:} // end of run function
act_obj.c:                //ch->reply = victim;
act_obj.c:                //ch->reply = victim;
act_obj.c:        // we allow giving quest eq to mobs specifically designed for this
act_obj.c:    // NPCs typically don't want items, so we drop them to prevent lots of possible screw-ups
act_obj.c:    // where players give the wrong items to the wrong NPCs
act_obj.c:            // unsuccessful cast (e.g. invalid target) does not use up charge
act_obj.c:            // unsuccessful cast (e.g. invalid target) does not use up charge
act_obj.c:            int cost = 5000000; //50k gold 
act_wiz.c:	//printf_to_char(ch,"%s\n\rbreak\n\r",pch);
act_wiz.c:   //page_to_char(buf,ch);
Binary file aeaea matches
alchemy.c:    int reset_nr; // for counting nr of herbs reset
alchemy.c:    { AAS+0,  SECT_FIELD,         0, 0 }, // Cutleaf
alchemy.c:    { AAS+1,  SECT_FOREST,        0, 0 }, // Alraune
alchemy.c:    { AAS+2,  SECT_HILLS,         1, 0 }, // Gust Grass
alchemy.c:    { AAS+3,  SECT_MOUNTAIN,      1, 0 }, // Fire Berry
alchemy.c:    { AAS+4,  SECT_WATER_SHALLOW, 2, 0 }, // Devil's Root
alchemy.c:    { AAS+5,  SECT_FIELD,         2, 0 }, // Angel Finger
alchemy.c:    { AAS+6,  SECT_DESERT,        3, 0 }, // Blood Thorn
alchemy.c:    { AAS+7,  SECT_FOREST,        3, 0 }, // Winterfox
alchemy.c:    { AAS+8,  SECT_HILLS,         4, 0 }, // Faerie Wing
alchemy.c:    { AAS+9,  SECT_WATER_SHALLOW, 4, 0 }, // Dragon's Bane
alchemy.c:    { AAS+10, SECT_DESERT,        4, 0 }, // Desert Rose
alchemy.c:    { AAS+11, SECT_MOUNTAIN,      4, 0 }, // Wind Wisper
alchemy.c://#define HERB_DEBUG
alchemy.c:    { AAS+00, SECT_FIELD,         0 }, // Cutleaf (mottled)
alchemy.c:    { AAS+01, SECT_FOREST,        0 }, // Alraune (black)
alchemy.c:    { AAS+02, SECT_HILLS,         1 }, // Gust Grass (silver)
alchemy.c:    { AAS+03, SECT_MOUNTAIN,      1 }, // Fire Berry (red)
alchemy.c:    { AAS+04, SECT_WATER_SHALLOW, 2 }, // Devil's Root (black)
alchemy.c:    { AAS+05, SECT_FIELDS,        2 }, // Angel Finger (mottled)
alchemy.c:    { AAS+06, SECT_DESERT,        3 }, // Blood Thorn (red)
alchemy.c:    { AAS+07, SECT_HILLS,         3 }, // Winterfox (silver)
alchemy.c:    { AAS+08, SECT_FOREST,        4 }, // Faerie Wing (silver, invis)
alchemy.c:    { AAS+09, SECT_WATER_SHALLOW, 4 }, // Dragon's Bane (black)
alchemy.c:    { AAS+10, SECT_DESERT,        5 }, // Desert Rose (red)
alchemy.c:    { AAS+11, SECT_MOUNTAIN,      5 }, // Wind Wisper (mottled)
alchemy.c:	//send_to_char( "Hmm.. seems something went wrong.\n\r", ch );
alchemy.c:                       //send_to_char( "You feel different.\n\r", victim );
alchemy.c:               //act("$n doesn't look like $mself anymore...",victim,NULL,NULL,TO_ROOM);
alchemy.c://             spell_change_sex( 82, 50, ch, *(ch), TAR_CHAR_NEUTRAL);
auth.c: * [S]imulated [M]edieval [A]dventure multi[U]ser [G]ame      |   \\._.//   *
auth.c:		// check in case name got denied in the meantime
bit.c:    //if ( is_stat( flag_table ) )
bsave.c:	    //REMOVE_BIT(ch->act, PLR_CONSENT);
bsave.c:			bread_number(buf); // This is "set". Don't want it, going to recalculate
buffer_util.c:  // get file size
buffer_util.c:  fseek(fp, 0L, 2); // jump to EOF
buffer_util.c:  fseek(fp, startPos, 0); // jump back
buffer_util.c:  // allocate buffer
buffer_util.c:  // read the file in
buffer_util.h://typedef struct mem_file_type MEMFILE;
buffer_util.h://moved this to merc.h
buffer_util.h:  //MEMFILE *storage_box;
buildutil.c:        //obj->extra_flags = value;
buildutil.c:        //obj->wear_flags = value;
buildutil.c:        //location->room_flags    = value;
clan.c:    clan = &(clan_table[clannum]);  // for readability
clan.c:        return;  // Execute every third tick for performance reasons.
comm.c:                // ensure we have feedback that an input was processed (some commands only provide feedback via prompt)
comm.c:            //quit_save_char_obj( ch );
comm.c:        //ch = original_char( d->character );
comm.c:            // copy remaining chars to beginning of string
comm.c:            //bug("Buffer overflow. Closing.\n\r",0);
comm.c:            //close_socket(d);
comm.c:    // limit total output written "in one go" to avoid write errors
comm.c:    // players may overwrite whether color is sent in raw format
comm.c:    char    buf[ MAX_STRING_LENGTH * 5 ]; // some safety space
comm.c:    // players may overwrite whether color is sent in raw format
comm.c:    // quick-and-dirty trick for quick downloading of notes */
comm.c:                              //		case 'n': i = PERS( ch,  to  );                         break;
comm.c:                              //		case 'N': i = PERS( vch, to  );                         break;
comm.c:    // pad
comm.c: *  http://pip.dknet.dk/~pip1773
comm.c:    //do_asave (NULL, ""); /* autosave changed areas */
comm.c:    // make sure we don't use BSD style of signal handling..
comm.c:    //act.sa_mask = ???;
const.c:	}, //10
const.c:	}, //20
const.c://1
const.c://2      
const.c:	}, //30
const.c://3      
const.c://4      
const.c:	}, //40
const.c://5
const.c://6
const.c://7
const.c://undead,wise
const.c://8
const.c://10
const.c:	}, //50
const.c:	}, //60 
const.c://   War  Thi  Cle  Mag  Gla  Sam  Pal  Asn  Nin  Mon  Tem  Ilu  Gun  Ran  Nec
const.c:// race 5 ^
const.c://r1
const.c://    War  Thi  Cle  Mag  Gla  Sam  Pal  Asn  Nin  Mon  Tem  Ilu  Gun  Ran  Nec
const.c:// race 20 ^
const.c:// race 25 ^
const.c://r2	
const.c://    War  Thi  Cle  Mag  Gla  Sam  Pal  Asn  Nin  Mon  Tem  Ilu  Gun  Ran  Nec
const.c:// race 30 ^	
const.c://r3
const.c://    War  Thi  Cle  Mag  Gla  Sam  Pal  Asn  Nin  Mon  Tem  Ilu  Gun  Ran  Nec
const.c:// race 35 ^
const.c://4
const.c://          War  Thi  Cle  Mag  Gla  Sam  Pal  Asn  Nin  Mon  Tem  Ilu  Gun  Ran  Nec
const.c:// race 40 ^        
const.c://5        
const.c://          War  Thi  Cle  Mag  Gla  Sam  Pal  Asn  Nin  Mon  Tem  Ilu  Gun  Ran  Nec
const.c:// race 45 ^        
const.c://6       
const.c://          War  Thi  Cle  Mag  Gla  Sam  Pal  Asn  Nin  Mon  Tem  Ilu  Gun  Ran  Nec
const.c:// race 50 ^
const.c://r7              
const.c:        //  War  Thi  Cle  Mag  Gla  Sam  Pal  Asn  Nin  Mon  Tem  Ilu  Gun  Ran  Nec
const.c:// race 55 ^
const.c://r8        
const.c://    char *  name;           /* the full name of the class */
const.c://    char    who_name    [4];    /* Three-letter name for 'who'  */
const.c://    sh_int  attr_prime;     /* Prime attribute      */
const.c://    sh_int  attr_second[2]; /* Secondary attributes  */
const.c://    sh_int  stat_weights[MAX_STATS]; /* weights for default roll assignment */
const.c://    sh_int  weapon;         /* First weapon         */
const.c://    sh_int  guild[MAX_GUILD];   /* Vnum of guild rooms      */
const.c://    sh_int  skill_adept;        /* Maximum skill level      */
const.c://    sh_int  attack_factor;      /* replace the old thac0 values --Bobble */
const.c://    sh_int  defense_factor;
const.c://    sh_int  hp_gain;
const.c://    sh_int  mana_gain;          /* Class gains mana on level    */
const.c://    sh_int  move_gain;
const.c://    char *  base_group;     /* base skills gained       */
const.c://    char *  default_group;      /* default skills gained    */
const.c://    War  Thi  Cle  Mag  Gla  Sam  Pal  Asn  Nin  Mon  Tem  Ilu  Gun  Ran  Nec
crafting.c://void craft_obj_stat( OBJ_DATA *obj, int ops );
crafting.c://void craft_obj_roll( OBJ_DATA *obj, int ops );
crafting.c://void craft_obj_max( OBJ_DATA *obj, int ops );
crafting.c:    { CRFT+0,  0 }, // Foul Essence
crafting.c:    { CRFT+1,  1 }, // Sparkling Essence
crafting.c:    { CRFT+2,  2 }, // Blissful Essence
crafting.c:    { CRFT+3,  0 }, // Bronze Smelt
crafting.c:    { CRFT+4,  1 }, // Iron Smelt
crafting.c:    { CRFT+5,  2 }, // Gold Smelt
crafting.c:    { CRFT+6,  3 }, // Adamantium Smelt
crafting.c:    { CRFT+7,  0 }, // Heavy Straps
crafting.c:    { CRFT+8,  1 }, // Metal Scraps
crafting.c:    { CRFT+14, 1 }, // Steel Rivet
crafting.c:    { CRFT+9,  2 }, // Fastening Bolts
crafting.c:    { CRFT+15, 2 }, // Wire Band
crafting.c:    { CRFT+10, 3 }, // Mephiston's Inspiration
crafting.c:    { CRFT+11, 3 }, // Rynor's Creativity
crafting.c:    { CRFT+12, 4 }, // Bobble's Brilliance
crafting.c:    { CRFT+13, 4 }, // Rimbol's Strength
crafting.c://fine, splendid, mighty, master, glorious, champion
crafting.c://12  , 30      , 50    , 91    , 92      , 97
crafting.c://other possible affixes for future use: heroic, magnificent, illustrious, radiant, imperial, marvelous
crafting.c:    { "champion_gauntlets",  CRFT+42, { CRFT+12, CRFT+13 },              97 }, // Bobble's Brilliance, Rimbol's Strength
crafting.c:    { "champion_ring",       CRFT+41, { CRFT+8,  CRFT+10,  CRFT+13 },    97 }, // Metal Scraps, Mephiston's Inspiration, Rimbol's Strength
crafting.c:    { "champion_necklace",   CRFT+40, { CRFT+2,  CRFT+6,   CRFT+11 },    97 }, // Blissful Essence, Adamantium Smelt, Rynor's Creativity
crafting.c:    { "champion_whip",       CRFT+39, { CRFT+1,  CRFT+5,   CRFT+12 },    97 }, // Sparkling Essence, Gold Smelt, Bobble's Brilliance
crafting.c:    { "champion_mace",       CRFT+38, { CRFT+5,  CRFT+6,   CRFT+9  },    97 }, // Gold Smelt, Adamantium Smelt, Fastening Bolts
crafting.c:    { "ornate_bracer",       CRFT+37, { CRFT+5,  CRFT+15 },              94 }, // Gold Smelt, Wire Band
crafting.c:    { "ornate_sword",        CRFT+36, { CRFT+1,  CRFT+4,   CRFT+14 },    94 }, // Sparkling Essence, Iron Smelt, Steel Rivet
crafting.c:    { "ornate_visor",        CRFT+35, { CRFT+5,  CRFT+9 },               94 }, // Gold Smelt, Fastening Bolts
crafting.c:    { "glorious_bracers",    CRFT+34, { CRFT+2,  CRFT+5 },               92 }, // Blissful Essence, Gold Smelt
crafting.c:    { "glorious_robe",       CRFT+33, { CRFT+4,  CRFT+9 },               92 }, // Iron Smelt, Fastening Bolts
crafting.c:    { "glorious_aura",       CRFT+32, { CRFT+0,  CRFT+1,   CRFT+2  },    92 }, // Foul Essence, Sparkling Essence, Blissful Essence
crafting.c:    { "glorious_boots",      CRFT+31, { CRFT+8,  CRFT+9,   CRFT+15 },    92 }, // Metal Scraps, Fastening Bolts, Wire Band
crafting.c:    { "master_ring",         CRFT+30, { CRFT+0,  CRFT+4,   CRFT+9  },    91 }, // Foul Essence, Iron Smelt, Fastening Bolts
crafting.c:    { "master_leggings",     CRFT+29, { CRFT+1,  CRFT+7,   CRFT+8  },    91 }, // Sparkling Essence, Heavy Strap, Metal Scraps
crafting.c:    { "master_polearm",      CRFT+28, { CRFT+3,  CRFT+4,   CRFT+14 },    91 }, // Bronze Smelt, Iron Smelt, Steel Rivet
crafting.c:    { "master_boots",        CRFT+27, { CRFT+0,  CRFT+7,   CRFT+9  },    91 }, // Foul Essence, Heavy Straps, Fastening Bolts
crafting.c:    { "mighty_spear",        CRFT+26, { CRFT+0,  CRFT+4 },               50 }, // Foul Essence, Iron Smelt
crafting.c:    { "mighty_breastplate",  CRFT+25, { CRFT+1,  CRFT+8 },               50 }, // Sparkling Essence, Metal Scraps
crafting.c:    { "mighty_vambrace",     CRFT+24, { CRFT+3,  CRFT+7 },               50 }, // Bronze Smelt, Heavy Straps
crafting.c:    { "splendid_shield",     CRFT+23, { CRFT+3,  CRFT+7 },               30 }, // Bronze Smelt, Heavy Straps
crafting.c:    { "splendid_orb",        CRFT+22, { CRFT+0,  CRFT+1 },               30 }, // Foul Essence, Sparkling Essence
crafting.c:    { "splendid_belt",       CRFT+21, { CRFT+7,  CRFT+8 },               30 }, // Heavy Straps, Metal Scraps
crafting.c:    { "fine_amulet",         CRFT+20, { CRFT+7 },                        12 }, // Heavy Straps
crafting.c:    { "fine_gloves",         CRFT+19, { CRFT+3 },                        12 }, // Bronze Smelt 
crafting.c:	    if ( !number_bits(2) )             // You have a better chance of getting saves & AC than HR/DR
crafting.c:	    if ( !number_bits(2) )             // You have a better chance of getting saves & AC than HR/DR
db2.c:        // convert to MOB_INDEX_DATA
db2.c:    // identical fields, just copy
db2.c:    // new fields
db2.c:        // boss mobs should keep their main stats (hp/damage/nr_attacks) unchanged during migration, to adjust later one by one
db2.c:        // approximation: boss mob = lvl 120+ with sanc or level 80+ in remort
db2.c:            // hitpoints
db2.c:            // damage
db2.c:            // number of attacks
db2.c:        // wealth - as we don't have shops loaded yet, this will result in excessive wealth percent for shopkeepers
db2.c:        // however, we cap at 200%, so no big deal
db2.c:        // set default values
db2.c:        // now read required and optional fields until END is encountered
db2.c:                // init race-specific defaults
db2.c:        } // end of single mob 
db2.c:        AFFECT_DATA *paf = NULL; // last affect read
db.c://    log_string( "Initialzing leaderboards");
db.c:  //  lboard_init();
db.c:    //log_string( "Loading leaderboard results" );
db.c:    //load_lboard_results();
db.c:    // debug
db.c:    //log_mob_index();
db.c:    // start checking for memory leaks now that we're ready
db.c:        // convert to ROM-style mobile
db.c:        // convert to Bobble-style mobile
db.c:    //debug
db.c:    //logpf("Fix_mobprogs: %d mprogs fixed.", mprog_count);
db.c:    //debug
db.c:    //logpf("Fix_mobprogs: %d mprogs fixed.", mprog_count);
db.c:    //debug
db.c:    //logpf("Fix_mobprogs: %d mprogs fixed.", mprog_count);
db.c:            //pObj->cost = 0;
db.c:    //reset_herbs( pRoom );
db.c:	default: // low chance for exotic weapon :)
db.c:    // money money money
db.c:    // level dependent stats (hp, damage, ...)
db.c:        // clear memory before usage - alloc_perm does it too, so the two can be used (more or less) interchangeably
db.c:    /* pMem = (void*) magic[1];   // mkw:should have intended effect */
db.c:    // auto-dump recently duplicated strings when memory leak is suspected
db.c://    argument = one_argument( argument, arg );
db.c:// return first (minimal) substring of s delimited by c_start and c_end
db.c:    // terminate string
db.c:// logs a backtrace
db.c:    // trace_msg[i] contains the address in hexadecimal in the form "..aeaea() [0x12345678]"
db.c:    // first, we extract the address information
db.c:    // we start at 1 to skip call of log_trace        
db.c:    // second, we feed the addresses into addr2line to get readable information
db.c:    //sprintf(cmd, "addr2line -pfs -e ../src/aeaea %s", address_buf);
fight2.c:// mama routine for burst, semi-auto and full-auto
fight2.c:    // do we have gun(s) to use?
fight2.c:    // ok, we're ready for action
fight2.c:    // work out number of attacks & chance of jamming
fight2.c:        // plus 1/3 to number of attacks
fight2.c:    // now the attacks
fight2.c:	//extract_obj( rope );
fight2.c:    // anyone can kick
fight2.c:    // allow disarm as a shortcut for tdisarm while out-of-combat
fight2.c:    // starting a fight if needed, regardless of success or failure
fight2.c:        af.duration = -1; // removed in special_affect_update
fight2.c:        // initial punch to set up
fight2.c:        // second blow for massive damage
fight2.c:  // prepare affect
fight2.c:// paladin smite good/evil attack
fight2.c:    // bonus damage is calculated in one_hit
fight2.c:    // chance to dispel if fighting opposing alignment
fight.c:    // get target
fight.c:        // may not be able to interfere
fight.c:        // may not want to rescue
fight.c:        // may not want to be rescued
fight.c:	 // no linkdeads unless fighting
fight.c:		// reduce damage during sunrise
fight.c:    // cap off-hand weight to effectively cap penalty
fight.c:    // dual wield requires weight difference
fight.c:    // dual weapon requires weapons of correct type
fight.c:            // adjust for weight in case offhand weapon is heavier
fight.c:    // combine the two skills, rounding down
fight.c:    // unarmed attacks
fight.c:    // armed but no offhand weapon
fight.c:    // everybody has a base chance, regardless of skill
fight.c:    // note: this should match the calculation in mob_base_attacks (mob_stats.c)
fight.c:        // bonus off-hand attack for haste
fight.c:    // wielding a one-handed weapon in two hands
fight.c:        // bonus is partially capped
fight.c:    // deal extra damage at the cost of moves
fight.c:    // the move cost applies whether or not the attack hits
fight.c:    // that's why we check it here rather than in deal_damage
fight.c:        // reduced cost for burst/semi-/full-auto
fight.c:        // half cost while not berserking (but less damage later)
fight.c:        // more damage for higher cost
fight.c:    // extra damage from smite attacks
fight.c:        // +5% to attack roll per size difference
fight.c:    // quirky's insanity is special
fight.c:    // now the "regular" elemental auras
fight.c:    // save for half damage is possible but harder than normal
fight.c:    // vitality no longer affects immunities directly
fight.c:    // Followers desert (strips charm)
fight.c:        // Sleeping victims wake up
fight.c:// if ch is a charmed NPC and leader is present, returns leader, otherwise ch
fight.c:    // touch spells and some others cannot be evaded
fight.c:    // direct-target spells are harder to evade
fight.c:    // non-spell damage may be reduced by a saving throw as well
fight.c:    // stone skin reduce damage but wears off slowly
fight.c:        // chance to reduce duration
fight.c:		//else dam -= (victim->hit/victim->max_hit - .25) * 2/3; Quirky, Quirky.. :P
fight.c:        // absorb only damage that would drop victim below 1 hp
fight.c:        // suicide during combat counts as kill by opponent
fight.c:                // trigger must come AFTER death-prevention, as mob remort can cause character to save
fight.c:		    else   // kill did not contribute to clanwar pkills, so don't mention clan (good for religion!)
fight.c:    // allow disbelief against illusion
fight.c:    // might still hit caster by pure chance
fight.c:    // allow disbelief against illusion
fight.c:    // might still hit caster by pure chance
fight.c:        // like auras, ranged attackers don't take damage from exploding images
fight.c:            // allow hard save for half damage
fight.c:    // offhand occupied means reduced block chance
fight.c:    // whips are harder to block
fight.c:        //  bug( "Set_fighting: already fighting", 0 );
fight.c:    // double check that set_fighting worked in case kill_trigger stopped it
fight.c:    // damage is at least victim's max hitpoints - anything less is a bug or an exploit
fight.c:    // e.g. having a charmie attack while not in the room (not remembered) to power-level low-level char
fight.c:    // NPC killing NPC without being in group. Happens e.g. when charm wears off.
fight.c:    // group penalty for large group, high/low align and level range
fight.c:        // alignment change
fight.c:        // partly exp from own, partly from group
fight.c:        // remort adjustment
fight.c:// compute baseline xp for character of given level_power killing victim
fight.c:    // general base bonus/penalty
fight.c:    // adjust based on hp & damage dealt by mob compared to average mob at character's level
fight.c:    // hitpoints - penalty or bonus
fight.c:    // damage - penalty or bonus
fight.c:    // number of attacks - penalty or bonus
fight.c:    // mobs with unusual hitroll/ac/saves
fight.c:    // adjustments for non-level dependent things
fight.c:        // dragons
fight.c:        // casters
fight.c:        // other
fight.c:        // adjust stance cost for purpose of bonus calculation
fight.c:    // reduce extreme amounts of base xp
fight.c:    // penalty for high-level chars - levels above 90 provide bonus-dice, so harder to achieve
fight.c:    // and bonus for low-ish characters
fight.c:    // bonus for newbies
fight.c:    // bonus for first 5 levels
fight.c:    // additive bonuses
fight.c:// returns "degree of of vulnerability" (0-1) - for xp calculation
fight.c:    // killing neutral-aligned non-sentients or undeads does nothing; same for aggro mobs
fight.c:    // killing evil victims makes you good, killing neutral or good victims makes you evil
fight.c:    // adjust based on xp gained - redemption requires effort, but killing harmless victims is still pretty evil
fight.c:    // scaling
fight.c:    // we now have a chance to escape, so lag is given now, regardless of success
fight.c:    // auto-fail chance based on number of available exits
fight.c:        // retreat skill allows fleeing regardless of number of exits
fight.c:        // harder to flee from PCs
fight.c:        //printf_to_char(ch, "ch_roll(%d) = %d vs %d = opp_roll(%d)\n\r", ch_base, ch_roll, opp_roll, opp_base);
fight.c:        // Thieves are exempt from XP penalty
fight.c:// players may want to stop raging to preserve moves
fight.c:    // may not succeed while fighting
fight.c:    // safety-net just in case we fail - e.g. races with permanent berserk
grep.c:	    value *= 100; // value in silver
grep.c:	    value *= 100; // value in silver
grep.c:    // negative stats only give 2/3 their OPs value
grep.c:    // bonuses in excess of the soft-cap cost 1/3 extra
grep.c:            default: result += 1000; break; // not allowed
grep.c:        // we don't use get_translucency_spec_penalty to avoid rounding issues
grep.c:    // bonuses for align restrictions
grep.c:    // bonuses for class restrictions
grep.c:    // bonus for randomness
grep.c:    // affects - check for duplicates circumventing soft/hardcaps
grep.c:    // ignore objects with no bonuses at all
grep.c:        int factor = spec < 0 ? -1 : 1; // saves & AC
grep.c:        // below negative spec
handler.c:    // male/female only races force base gender
handler.c:    // reset sex
handler.c:    // reset stats
handler.c:    // adjust XP to fit within current level range (needed e.g. when racial ETL is adjusted)
handler.c:    // wimpy & calm percentages
handler.c:    // remorted characters have at least trust equal to highest level they reached previously
handler.c:    //sprintf( buf, "%s%s%s{x", ch->pcdata->name_color, ch->pcdata->pre_title, ch->name);
handler.c:    // okay, move all the old flags into new vectors if we have to 
handler.c://    case APPLY_COMBO:    ch->combo_points += mod; break;
handler.c:// Check if ch is really in some room - may not be the case right after login
handler.c:    check_explore(ch, pRoomIndex); //Explore the room
handler.c:    // remove current tattoo effect
handler.c:    // wear item - this is picked up by tattoo_modify_equip
handler.c:    // add new tattoo effect
handler.c:    // add item armor / affects
handler.c:    // we delayed weapon-drop check until all affects (equipment & tattoo) have been applied
handler.c:    // remove current tattoo effect
handler.c:    // remove item - this is picked up by tattoo_modify_equip
handler.c:    // add new tattoo effect
handler.c:    // add item armor / affects
handler.c:    // we delayed weapon-drop check until all affects (equipment & tattoo) have been applied
handler.c:    // search in room first, keeping count
handler.c:    // then in area, excluding room
handler.c:    // finally in world
handler.c:    // check in room first
handler.c:    // then all others
handler.c:// find object of given type in content list
handler.c:	//&& !IS_SET(pRoomIndex->room_flags, ROOM_NEWBIES_ONLY)
handler.c:bool ignore_invisible = FALSE; // hunt etc.
handler.c://    case APPLY_COMBO:   return "combo points";
hunt.c:    // players are responsible for their charmies
interp.c://    { "combo",      do_combo,   POS_SLEEPING,    0,  LOG_NORMAL, 1, FALSE, FALSE  },
interp.c://    { "powerthrust",do_power_thrust, POS_FIGHTING, 0, LOG_NORMAL, 1, FALSE, TRUE },
interp.c:    // Meta-magic commands.
interp.c://    { "pipe",       do_pipe,    POS_DEAD,   ML,  LOG_ALWAYS, 1, FALSE, FALSE  },
interp.c:    //{ "luareset",   do_luareset,POS_DEAD,   L2,  LOG_ALWAYS, 1, FALSE, FALSE  },
interp.h:// DECLARE_DO_FUN( do_combo    );
lua_bits.c:// added cast to Integer to get rid of compiler error
lua_bits.c:// convert string into an integral number in any base in range 2-36 (written by Nick Gammon)
lua_bits.c:// eg. n = bit.fromhex ("ABCDEF")
lua_bits.c:  // get text to convert
lua_bits.c:  // maximum value before multiply by the base
lua_bits.c:  maxvalue = 4503599627370496 / base;   // 2^52
lua_bits.c:  // skip whitespace
lua_bits.c:    ;  // skip leading spaces
lua_bits.c:  // look for sign
lua_bits.c:    // The largest mantissa a double can have it 52 bits
lua_bits.c:      digit = 999;   // bad digit - force error in next line
lua_bits.c:    } // end while
lua_bits.c:  return 1;  // number of result fields
lua_bits.c:  } // end of bit_tonumber
lua_bits.c:  {"neg",   bit_bnot},         // was bnot in Reuben's library
lua_bits.c:  {"xor",   bit_bxor},         // was bxor in Reuben's library
lua_bits.c:  {"shl",   bit_lshift},       // was lshift in Reuben's library
lua_bits.c:  {"shr",   bit_rshift},       // was rshift in Reuben's library
lua_bits.c:  {"ashr",  bit_arshift},      // was arshift in Reuben's library
lua_bits.c:  {"mod",   bit_mod},          // new
lua_bits.c:  {"tonumber", bit_tonumber},  // new by Nick
lua_bits.c:// register library
lua_scripting.c: * [S]imulated [M]edieval [A]dventure multi[U]ser [G]ame      |   \\._.//   *
lua_scripting.c:Post queries at: http://www.gammon.com.au/forum/
lua_scripting.c:http://www.gammon.com.au/forum/?id=8015
lua_scripting.c:// number of items in an array
lua_scripting.c:        //log_string("already exists in make_ud_table");
lua_scripting.c:        //bugf("%d",UDTYPE);  
lua_scripting.c:    lua_remove(g_mud_LS, -1); // kill the nil 
lua_scripting.c:    // do some if is number thing here eventually
lua_scripting.c:    // Send empty string for no argument
lua_scripting.c:        // Nothing, must be in a container
lua_scripting.c:            //set_char_color( AT_YELLOW, ch );
lua_scripting.c:        lua_getglobal( g_mud_LS, "run_lua_interpret"); //what we'll call if no errors
lua_scripting.c:        d->lua.incmpl=FALSE; //force it whehter it was or wasn't
magic2.c:// everyone who fails a save makes an attack against the target
magic2.c:    // ensure the victim attacks caster rather than traitor if used to initiate combat
magic2.c:        // one full attack against the target, the return to normal fight
magic2.c:        // this uses up the next full attack for the traitor
magic2.c:    arg = one_argument( target_name, buf ); // weapon name
magic2.c:	    arg2 = one_argument( arg2, buf ); // level
magic2.c:    one_argument( target_name, buf ); // level
magic2.c:        // can summon from fountain (e.g. create spring), but level will be lower
magic2.c:    // set name, description etc. to match liquid
magic2.c:    else   // ch IS_GOOD
magic2.c:            // get max duration once for each spell
magic2.c:    af.bitvector = dice(2,4) + level/16; // number of images
magic2.c:    // some fire damage ...
magic2.c:    // ... and some light damage & blindness
magic2.c:        // chance to blind
magic2.c:    //CHAR_DATA *victim = (CHAR_DATA *) vo;
magic2.c:    //printf_to_char(ch," gsn: %d sn: %d\n\r", gsn_overcharge, sn);
magic2.c://    af.bitvector = 0;
magic2.c:    // same-aligned targets are safe
magic2.c:    // opposite aligned targets get hurt
magic2.c:    af.bitvector = dice(2,4) + level/8; // number of images
magic.c:    // level bonus
magic.c:        // tweak so physically oriented classes get better physical and worse magic saves
magic.c:    // WIS or VIT bonus
magic.c:    // non-boss NPCs don't disrupt quite so much
magic.c:// global variable for storing what meta-magic skills are used
magic.c:// meta-magic casting functions
magic.c:    // parse meta-magic flags requested
magic.c:        // valid flag?
magic.c:        // character has skill?
magic.c:    // each meta-magic effect doubles casting cost
magic.c:    // can't reduce below half a round (e.g. dracs)
magic.c:    // each meta-magic effect has chance of failure
magic.c:// remove invalid meta-magic effects
magic.c:    // can only extend spells with duration
magic.c:    // can only quicken spells with longish casting time
magic.c:    // can only chain single-target non-personal spells
magic.c:    // spell triggers
magic.c:        return; // Return because it might have killed the victim or ch
magic.c:    // strip meta-magic options that are invalid for the spell & target
magic.c:    // mana cost must be calculated after meta-magic effects have been worked out
magic.c:        // remove invisibility etc.
magic.c:        // no need
magic.c:        // failure
magic.c:            // remove berserk, but not calm yet - halfway there
magic.c:        if ( next_vict == NULL ) // removed this to let the chain continue viciously!  || next_vict == victim )
magic.c:    //int mana;
magic.c:    //int skill;
magic.c:        //mana = (200-skill)*mana/1000;
magic.c:        //ch->mana += mana;
magic.c:        //        affect_strip ( ich, gsn_sneak           );
magic.c:// returns original room unless a misgate occurs, in which case a random room is returned
magic.c:        // warpstone prevents misgate but is destroyed in the process
magic.c:        //return;
magic.c:        //return;                       
magic.c:    //printf_to_char(ch, "gsn: %d sn: %d", gsn_haste, sn);
magic.c:        // || saves_spell(level,victim,DAM_CHARM))
magic.c:        //return;
magic.c:        //return;
magic.c:    // misgate chance when cursed but not normally
makefile:PARENT	:= \""$(shell hg summary | grep parent | sed 's/parent: //')"\"
merc.h:#define aa          67108864    // doubled due to conflicts
merc.h:#define aa          27    // doubled due to conflicts
merc.h:#define ff          33    // bit 32 wasn't used in old-style
merc.h:#define FORM_UNDEAD             (I) //vuln-immune to some spells
merc.h:#define FORM_CONSTRUCT          (J) //train stats to max for gold
merc.h:#define FORM_AGILE              (N) //10 move per level
merc.h:#define FORM_PLANT              (U)  //grow roots
merc.h:#define FORM_BRIGHT             (dd) //self light source
merc.h:#define FORM_TOUGH              (ee) //10 hp per level
merc.h:#define FORM_SUNBURN            (ff) //damage from sun when outdoors
merc.h:#define FORM_DOUBLE_JOINTED     (gg) //better dodging
merc.h:#define FORM_FROST              (hh) //frost aura
merc.h:#define FORM_BURN               (ii) //burning aura
merc.h:#define FORM_WISE               (jj) //10 mana per level
merc.h:#define FORM_CONDUCTIVE         (kk) //electric aura
merc.h:// #define APPLY_COMBO              31
merc.h://        int         combo_points;   
merc.h://extern sh_int  gsn_combo_attack;
merc.h:   //char type[MSL];
merc.h://#define ACHV_TATT	14
merc.h://#define PERS(ch, looker) get_mimic_PERS_new(ch, looker, NULL)
merc.h://#define PERS(ch, looker, gagtype) get_mimic_PERS_new(ch, looker, gagtype)
merc.h://#define PROMPT_DEFAULT "{g<{r%h{g/%Hhp {b%m{g/%Mmn {c%v{g/%Vmv {y%X{getl{W%z{x>{x "
mob_cmds.c:// used by do_mptransfer and do_mpgtransfer
mob_cmds.c:            // when removing specific object, only remove first
mob_cmds.c:    // usage should be logged
mob_prog.c:// does the mob have a trigger of the given type with vnum as parameter
mob_stats.c:// wealth
mob_stats.c:// hitpoints
mob_stats.c:// mana
mob_stats.c:// moves
mob_stats.c:// armor
mob_stats.c:// saves
mob_stats.c:// hitroll
mob_stats.c:// damroll
mob_stats.c:// damage
mob_stats.c:// number of attacks (in percent)
mob_stats.c:// note: this should match the calculation in mob_hit (fight.c)
mt19937ar.c:   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
mt19937ar.c://#include <stdio.h>
mt19937ar.c:// the one I have chosen - NJG
mt19937ar.c:  //return genrand_real2 ();  // normal reals, (0,1] interval
mt19937ar.c:  // This version done by Nick Gammon to properly use all 53 bits
mt19937ar.c:  // produced by 2 calls to genrand_int32.
mt19937ar.c:  // I think the one above loses precision as it does the multiply 
mt19937ar.c:  // then the add.
mt19937ar.c:  long long a = genrand_int32() >> 5, //27 bits
mt19937ar.c:            b = genrand_int32() >> 6; //26 bits
mt19937ar.c:  // Note that the  genrand_res53 version gave a poor result on the
mt19937ar.c:  // Chi Squared distribution test (5%)
mt19937ar.c:  // This one gives 50%
nanny.c:	    //sprintf( msg, "%s{%c%s ", msg,colour, race_table[race].name );
nanny.c://		strcat( buf, "{x ]\n\r{CChoose a class(for more information type HELP, STATS, or ETLS):{x" );
nanny.c://		sprintf( buf, "{CWhat is your class (for more information type HELP, STATS, or ETLS)?{x" );
nanny.c://		sprintf( buf, "{CWhat is your class (for more information type HELP, STATS, or ETLS)?{x" );
nanny.c://		sprintf( buf, "{CWhat is your class (for more information type HELP, STATS, or ETLS)?{x" );
nanny.c://		strcat( buf, "{CWhat is your class(for more information type HELP, STATS, or ETLS)?{x" );
nanny.c:        //write_to_buffer(d,"You already have the following skills:\n\r",0);
nanny.c:        //do_skills(ch,"");
nanny.c:        //do_spells(ch,"");
nanny.c:	//	remove_from_quit_list( ch->name );
nanny.c:    { "{WThere are maps available on our website of many areas. http://www.aarchonmud.com{x "               }, 
nanny.c:	//remove_from_quit_list( ch->name );
nanny.c:        //do_loginquote(ch);
olc_act.c:    //EDIT_ROOM(ch, pRoom);
olc_act.c:    {1,1,500,150          },// 1
olc_act.c:    {1,1,3000,900         },//5
olc_act.c:    {2,2,7000,2100        },//10
olc_act.c:    {3,3,12000,3600       },//15
olc_act.c:    {4,4,18000,5400       },//20
olc_act.c:    {6,6,25000,7500       },//25
olc_act.c:    {7,7,33000,9900       },//30
olc_act.c:    {8,8,42000,12600      },//35
olc_act.c:    {9,9,52000,15600      },//40
olc_act.c:    {10,10,63000,18900    },//45
olc_act.c:    {11,11,75000,22500    },//50
olc_act.c:    {12,12,88000,26400    },//55
olc_act.c:    {13,13,102000,30600   },//60
olc_act.c:    {14,14,117000,35100   },//65
olc_act.c:    {16,16,133000,39900   },//70
olc_act.c:    {17,17,150000,45000   },//75
olc_act.c:    {18,18,168000,50400   },//80
olc_act.c:    {19,19,187000,56100   },//85
olc_act.c:    {20,20,216000,64800   },//90
olc_act.c:    {21,21,510000,153000  },//95
olc_act.c:    {22,22,600000,180000  },//100
olc_act.c:        int factor = spec < 0 ? -1 : 1; // saves & AC
olc_act.c:        // exceeding hard spec
olc_act.c:        // below negative spec
olc_act.c:    // AC
olc_act.c:    // cost
olc_act.c:    // weight
olc_act.c:    {  2,  7,   121,  2,  4,  2,   40,   60 }, // 10
olc_act.c:    {  3,  9,   333,  2,  8,  5,  -25,   20 }, // 20
olc_act.c:    {  6, 12,   853,  4,  6,  8,  -90,  -20 }, // 30
olc_act.c:    { 15, 10,  1850,  4,  8, 13, -150,  -60 }, // 40
olc_act.c:    { 50, 10,  4500,  5,  8, 19, -215, -100 }, // 50
olc_act.c:    { 50, 10,  9500,  8,  6, 28, -275, -140 }, // 60
olc_act.c:    { 65, 10, 11500,  8,  7, 30, -340, -180 }, // 70
olc_act.c:    { 60, 10, 13500, 11,  6, 34, -400, -220 }, // 80
olc_act.c:    { 65, 15, 14500, 19,  4, 36, -460, -260 }, // 90
olc_act.c:    { 65, 15, 18000, 11,  8, 38, -525, -300 }, // 100
olc_act.c:    { 65, 15, 22500, 12,  8, 44, -580, -340 }, // 110
olc_act.c:    { 65, 15, 27000, 12,  8, 56, -750, -380 } // 120
olc_act.c:    // damage dice
olc_act.c:    // base stats
olc_apcode.c:   //{  "list",     apedit_list    },
olc_apcode.c:   //{  "if",       apedit_if      },
olc_apcode.c:   //{  "mob",      apedit_mob     },
olc_apcode.c:   //{  "lua",      apedit_lua     },
olc_apcode.c:// void fix_aprog_objs( CHAR_DATA *ch, APROG_CODE *pAcode )
olc_apcode.c:// {
olc_apcode.c:    // APROG_LIST *mpl;
olc_apcode.c:    // int hash;
olc_apcode.c:    // char buf[MSL];
olc_apcode.c:    // OBJ_INDEX_DATA *obj;
olc_apcode.c:    // if ( pAcode != NULL )
olc_apcode.c:        // for ( hash = 0; hash < MAX_KEY_HASH; hash++ )
olc_apcode.c:            // for ( obj = obj_index_hash[hash]; obj; obj = obj->next )
olc_apcode.c:                // for ( mpl = obj->aprogs; mpl; mpl = mpl->next )
olc_apcode.c:                    // if ( mpl->vnum == pAcode->vnum )
olc_apcode.c:                    // {
olc_apcode.c:                        // sprintf( buf, "Fixing obj %d.\n\r", obj->vnum );
olc_apcode.c:                        // send_to_char( buf, ch );
olc_apcode.c:                        // mpl->code = pAcode->code;
olc_apcode.c:                        // lua_load_aprog( mud_LS, pAcode->vnum, pAcode->code);
olc_apcode.c:                        // ptc(ch, "Fixed lua script for %d.\n\r", pAcode->vnum);
olc_apcode.c:                    // } 
olc_apcode.c:// }
olc_apcode.c:// #if 0
olc_apcode.c:// APEDIT(apedit_lua)
olc_apcode.c:// {
olc_apcode.c:    // APROG_CODE *pAcode;
olc_apcode.c:    // APROG_LIST *mpl;
olc_apcode.c:    // EDIT_APCODE(ch, pAcode);
olc_apcode.c:    // OBJ_INDEX_DATA *mob;
olc_apcode.c:    // int hash;
olc_apcode.c:    // char buf[MSL];
olc_apcode.c:    // pAcode->is_lua = !pAcode->is_lua;
olc_apcode.c:    // ptc( ch, "LUA set to %s\n\r", pAcode->is_lua ? "TRUE" : "FALSE" );
olc_apcode.c:    // if ( pAcode->is_lua )
olc_apcode.c:        // lua_mprogs++;
olc_apcode.c:    // else
olc_apcode.c:        // lua_mprogs--;
olc_apcode.c:    // fix_mprog_mobs( ch, pAcode);
olc_apcode.c:// }
olc_apcode.c:// #endif
olc_apcode.c:// #if 0
olc_apcode.c:// APEDIT( apedit_list )
olc_apcode.c:// {
olc_apcode.c:   // int count = 1;
olc_apcode.c:   // APROG_CODE *mprg;
olc_apcode.c:   // char buf[MAX_STRING_LENGTH];
olc_apcode.c:   // BUFFER *buffer;
olc_apcode.c:   // bool fAll = !str_cmp(argument, "all");
olc_apcode.c:   // char blah;
olc_apcode.c:   // AREA_DATA *ad;
olc_apcode.c:   // buffer = new_buf();
olc_apcode.c:   // for (mprg = mprog_list; mprg !=NULL; mprg = mprg->next)
olc_apcode.c:      // if ( fAll || IS_BETWEEN(ch->in_room->area->min_vnum, mprg->vnum, ch->in_room->area->max_vnum) )
olc_apcode.c:      // {
olc_apcode.c:         // ad = get_vnum_area(mprg->vnum);
olc_apcode.c:         // if ( ad == NULL )
olc_apcode.c:            // blah = '?';
olc_apcode.c:         // else
olc_apcode.c:            // if ( IS_BUILDER(ch, ad) )
olc_apcode.c:               // blah = '*';
olc_apcode.c:            // else
olc_apcode.c:               // blah = ' ';
olc_apcode.c:            // sprintf(buf, "[%3d] (%c) %5d\n\r", count, blah, mprg->vnum );
olc_apcode.c:            // add_buf(buffer, buf);
olc_apcode.c:            // count++;
olc_apcode.c:      // }
olc_apcode.c:      // if ( count == 1 )
olc_apcode.c:      // {
olc_apcode.c:         // if ( fAll )
olc_apcode.c:            // add_buf( buffer, "No existen progs.\n\r" );
olc_apcode.c:         // else
olc_apcode.c:            // add_buf( buffer, "No existen progs en esta area.\n\r" );
olc_apcode.c:      // }
olc_apcode.c:      // page_to_char(buf_string(buffer), ch);
olc_apcode.c:      // free_buf(buffer);
olc_apcode.c:      // return FALSE;
olc_apcode.c:// }
olc_apcode.c:// #endif
olc_apcode.c:// #if 0
olc_apcode.c:// /* define in mob_prog.c and mob_cmd.c */
olc_apcode.c:// typedef char* keyword_list[][2];
olc_apcode.c:// extern const keyword_list fn_keyword;
olc_apcode.c:// /* display valid if-checks */
olc_apcode.c:// APEDIT( apedit_if )
olc_apcode.c:// {
olc_apcode.c:    // BUFFER *buffer;
olc_apcode.c:    // char buf[MSL];
olc_apcode.c:    // int i;
olc_apcode.c:    // buffer = new_buf();
olc_apcode.c:    // add_buf( buffer, "==================== Valid if-checks ====================\n\r" );
olc_apcode.c:    // for( i = 0; fn_keyword[i][0][0] != '\n'; i++ )
olc_apcode.c:    // {
olc_apcode.c:	// sprintf( buf, "%-14s: %s\n\r", fn_keyword[i][0], fn_keyword[i][1] );
olc_apcode.c:	// add_buf( buffer, buf );
olc_apcode.c:    // }
olc_apcode.c:    // page_to_char(buf_string(buffer), ch);
olc_apcode.c:    // free_buf(buffer);
olc_apcode.c:    // return FALSE;
olc_apcode.c:// }
olc_apcode.c:// /* display valid mob commands */
olc_apcode.c:// APEDIT( apedit_mob )
olc_apcode.c:// {
olc_apcode.c:    // BUFFER *buffer;
olc_apcode.c:    // char buf[MSL];
olc_apcode.c:    // int i;
olc_apcode.c:    // buffer = new_buf();
olc_apcode.c:    // add_buf( buffer, "==================== Valid mob-commands =================\n\r" );
olc_apcode.c:    // for( i = 0; mob_cmd_table[i].name[0] != '\0'; i++ )
olc_apcode.c:    // {
olc_apcode.c:	// sprintf( buf, "mob %s %s\n\r", mob_cmd_table[i].name, mob_cmd_table[i].help );
olc_apcode.c:	// add_buf( buffer, buf );
olc_apcode.c:    // }
olc_apcode.c:    // page_to_char(buf_string(buffer), ch);
olc_apcode.c:    // free_buf(buffer);
olc_apcode.c:    // return FALSE;
olc_apcode.c:// }
olc_apcode.c:// #endif
olc_opcode.c:   //{  "list",     opedit_list    },
olc_opcode.c:   //{  "if",       opedit_if      },
olc_opcode.c:   //{  "mob",      opedit_mob     },
olc_opcode.c:   //{  "lua",      opedit_lua     },
olc_save.c://#define DIF(a,b) (~((~a)|(b)))
olc_save.c:    // flags must come after race, apart from that order does not matter
passive.c:// void  passive_update args( (CHAR_DATA *ch) );
playback.c:    //check visibility
playback.c:    //now mimic
protocol.c:    * http://tintin.sourceforge.net/mssp/
protocol.c:#endif // USING_MCCP
protocol.h:#define MUDLET_PACKAGE "1\nhttp://blah.org/download/MY_GUI.mpackage"
protocol.h: * number of the unicode character (see http://www.unicode.org/charts), then '/' 
quest.c:#define QUEST_ITEM1 10387 //Sword of Kings
quest.c:#define QUEST_ITEM2 10389 //Staff of Ancients
quest.c:#define QUEST_ITEM4 10380 //Old Smote's
quest.c:#define QUEST_ITEM5 10381 //Old Rimbol's
quest.c:#define QUEST_ITEM6 10382 //Old Meph's
quest.c:#define QUEST_ITEM7 10383 //Old Swayde
quest.c:#define QUEST_ITEM8 10384 //Old Para
quest.c:#define QUEST_ITEM9 10385 //Old Firewitch
quest.c:#define QUEST_ITEM10 22050 //Old Lilith
quest.c:#define QUEST_ITEM11 10388 //Old Quirky
quest.c:#define QUEST_ITEM12 10398 //Old Siva
quest.c:#define QUEST_ITEM13 22051 //Old Eris
quest.c:#define QUEST_ITEM14 22052 //Old Bobble
quest.c:#define QUEST_ITEM15 22053 //Old Drexl
quest.c:#define QUEST_ITEM16 4700 //New Quirky
quest.c:#define QUEST_ITEM17 4701 //New Lilith
quest.c:#define QUEST_ITEM18 4702 //New Firewitch
quest.c:#define QUEST_ITEM19 4703 //New Eris
quest.c:#define QUEST_ITEM20 4704 //New Drexl
quest.c:#define QUEST_ITEM21 4705 //New Parademia
quest.c:#define QUEST_ITEM22 4706 //New Swayde
quest.c:#define QUEST_ITEM23 4707 //New Siva
quest.c:#define QUEST_ITEM24 4708 //New Mephison
quest.c:#define QUEST_ITEM25 4709 //New Bobble
quest.c:#define QUEST_ITEM26 4710 //New Rimbol
quest.c:#define QUEST_ITEM27 4711 //New Smote
quest.c:#define QUEST_ITEM28 4712 //Maedhros Leggings
quest.c:#define QUEST_ITEM29 4726 //Quantum Shield
quest.c:	    qp_gain = qi->cost;//refund full cost on old items
quest.c:// division with randomized rounding
quest.c:    // need to be careful with signs - C rounding is towards 0
quest.c:        // kill mob quest (completed)
quest.c:        // collect X of ages quest (completed)
quest.c:        // general adjustments
quest.c:        // notify of rewards
quest.c:        // hand out rewards
quest.c:        // cleanup
quest.c:        // tracking
recycle.c://    pcdata->buffer = new_buf();
recycle.c:    pcdata->explored = (EXPLORE_DATA *)calloc(1, sizeof(*(pcdata->explored) ) ); //Allocate explored data
recycle.c:   // free_buf(pcdata->buffer);
recycle.h://#define DD DESCRIPTOR_DATA
recycle.h://DD	*new_descriptor args( (void) );
recycle.h://#undef DD
religion.c://#define REL_DEBUG
religion.c://#define DAY 60
religion.c://extern bool in_religion_war( CHAR_DATA *ch );
religion.c://    rel->war_status = NULL;
religion.c://    free_religion_war_list( religion->war_status );
religion.c://    Don't bother saving war_status anymore, since wars are removed
religion.c://    if ( rel->war_status != NULL )
religion.c://    {
religion.c://	bprintf( fp, "Warstatus\n" );
religion.c://	religion_war_save_to_buffer( rel->war_status, fp );
religion.c://    }
religion.c://	case 'W':
religion.c://	    if ( !str_cmp(word, "Warstatus") )
religion.c://	    {
religion.c://		religion->war_status = religion_war_load_from_file(fp);
religion.c://		fMatch = TRUE;
religion.c://		break;
religion.c://	    }
religion.c://	    break;
religion.c:// int religion_get_war_status( RELIGION_DATA *religion, RELIGION_DATA *opp )
religion.c:// {
religion.c://     RELIGION_WAR_DATA *war;
religion.c:// 
religion.c:// #ifdef REL_DEBUG
religion.c://     log_string( "religion_get_war_status: start" );
religion.c:// #endif
religion.c:// 
religion.c://     for ( war = religion->war_status; war != NULL; war = war->next )
religion.c:// 	if ( war->opp == opp )
religion.c:// 	{
religion.c:// #ifdef REL_DEBUG
religion.c:// 	    log_string( "religion_get_war_status: done" );
religion.c:// #endif
religion.c:// 	    return war->status;
religion.c:// 	}
religion.c:// 
religion.c:// #ifdef REL_DEBUG
religion.c://     log_string( "religion_get_war_status: done" );
religion.c:// #endif
religion.c:// 
religion.c://     return RELIGION_WAR_PEACE;
religion.c:// }
religion.c:// void religion_set_war_status( RELIGION_DATA *religion, RELIGION_DATA *opp, int status )
religion.c:// {
religion.c://     RELIGION_WAR_DATA *war;
religion.c:// 
religion.c:// #ifdef REL_DEBUG
religion.c://     log_string( "religion_set_war_status: start" );
religion.c:// #endif
religion.c:// 
religion.c://     if ( religion == opp )
religion.c:// 	return;
religion.c://     /* peace is default - don't store */
religion.c://     if ( status == RELIGION_WAR_PEACE )
religion.c://     {
religion.c:// 	religion_remove_war_status( religion, opp );
religion.c:// 	return;
religion.c://     }
religion.c://    for ( war = religion->war_status; war != NULL; war = war->next )
religion.c:// 	if ( war->opp == opp )
religion.c:// 	{
religion.c://	    war->status = status;
religion.c:// #ifdef REL_DEBUG
religion.c:// 	    log_string( "religion_set_war_status: done" );
religion.c:// #endif
religion.c://	    return;
religion.c://	}
religion.c://
religion.c://    /* if not found, create new */
religion.c://    war = new_religion_war( opp, status );
religion.c://    war->next = religion->war_status;
religion.c://    religion->war_status = war;
religion.c://
religion.c:// #ifdef REL_DEBUG
religion.c://    log_string( "religion_set_war_status: done" );
religion.c:// #endif
religion.c://
religion.c:// }
religion.c://
religion.c:// void religion_remove_war_status( RELIGION_DATA *religion, RELIGION_DATA *opp )
religion.c:// {
religion.c://    RELIGION_WAR_DATA *war, *next;
religion.c://
religion.c:// #ifdef REL_DEBUG
religion.c://     log_string( "religion_remove_war_status: start" );
religion.c:// #endif
religion.c://
religion.c://    if ( religion->war_status == NULL )
religion.c:// 	return;
religion.c://
religion.c://     if ( religion->war_status->opp == opp )
religion.c://     {
religion.c:// 	war = religion->war_status;
religion.c:// 	religion->war_status = war->next;
religion.c:// 	free_religion_war( war );
religion.c:// #ifdef REL_DEBUG
religion.c://     log_string( "religion_remove_war_status: done" );
religion.c:// #endif
religion.c:// 	return;
religion.c://     }
religion.c:// 
religion.c://     for ( war = religion->war_status; war->next != NULL; war = war->next )
religion.c:// 	if ( war->next->opp == opp )
religion.c:// 	{
religion.c:// 	    next = war->next;
religion.c:// 	    war->next = next->next;
religion.c:// 	    free_religion_war( next );
religion.c:// #ifdef REL_DEBUG
religion.c://     log_string( "religion_remove_war_status: done" );
religion.c:// #endif
religion.c:// 	    return;
religion.c:// 	}
religion.c:// }
religion.c://    /* fix the religion wars */
religion.c://    assign_religion_war_opp();
religion.c://    /* remove war status in other religions */
religion.c://    for ( rel = religion_list; rel != NULL; rel = rel->next )
religion.c://	religion_remove_war_status( rel, religion );
religion.c:// /* fix religion war lists after loading all religions */
religion.c:// void assign_religion_war_opp()
religion.c:// {
religion.c://     RELIGION_DATA *rel;
religion.c://     RELIGION_WAR_DATA *war;
religion.c://    
religion.c:// #ifdef REL_DEBUG
religion.c://     log_string( "assign_religion_war_opp: start" );
religion.c:// #endif
religion.c:// 
religion.c://    for ( rel = religion_list; rel != NULL; rel = rel->next )
religion.c:// 	for ( war = rel->war_status; war != NULL; war = war->next )
religion.c:// 	    war->opp = get_religion_by_ID( war->opp_ID );
religion.c://
religion.c:// #ifdef REL_DEBUG
religion.c://     log_string( "assign_religion_war_opp: done" );
religion.c:// #endif
religion.c://
religion.c:// }
religion.c:// RELIGION_WAR_DATA* new_religion_war( RELIGION_DATA *opp, int status )
religion.c:// {
religion.c://     RELIGION_WAR_DATA *war;
religion.c:// 
religion.c:// #ifdef REL_DEBUG
religion.c://     log_string( "new_religion_war: start" );
religion.c:// #endif
religion.c:// 
religion.c://     war = alloc_mem( sizeof(RELIGION_WAR_DATA) );
religion.c:// 
religion.c://     war->next = NULL;
religion.c://     war->opp = opp;
religion.c://     war->status = status;
religion.c:// 
religion.c:// #ifdef REL_DEBUG
religion.c://     log_string( "new_religion_war: done" );
religion.c:// #endif
religion.c:// 
religion.c://     return war;
religion.c:// }
religion.c:// 
religion.c:// void free_religion_war( RELIGION_WAR_DATA *war )
religion.c:// {
religion.c://     free_mem( war, sizeof(RELIGION_WAR_DATA) );
religion.c:// }
religion.c:// 
religion.c:// void free_religion_war_list( RELIGION_WAR_DATA *war )
religion.c:// {
religion.c://     RELIGION_WAR_DATA *next;
religion.c:// 
religion.c:// #ifdef REL_DEBUG
religion.c://     log_string( "free_religion_war_list: start" );
religion.c:// #endif
religion.c:// 
religion.c://     while ( war != NULL )
religion.c://     {
religion.c:// 	next = war->next;
religion.c:// 	free_religion_war( war );
religion.c:// 	war = next;
religion.c://     }
religion.c:// 
religion.c:// #ifdef REL_DEBUG
religion.c://     log_string( "free_religion_war_list: done" );
religion.c:// #endif
religion.c:// 
religion.c:// }
religion.c:// 
religion.c:// void religion_war_save_to_buffer( RELIGION_WAR_DATA *war, DBUFFER *fp )
religion.c:// {
religion.c:// 
religion.c:// #ifdef REL_DEBUG
religion.c://    log_string( "religion_war_save_to_buffer: start" );
religion.c:// #endif
religion.c:// 
religion.c://     while ( war != NULL )
religion.c://     {
religion.c:// 	bprintf( fp, "War %d %d\n", war->opp->ID, war->status );
religion.c:// 	war = war->next;
religion.c://     }
religion.c://     bprintf( fp, "End\n" );
religion.c:// 
religion.c:// #ifdef REL_DEBUG
religion.c://     log_string( "religion_war_save_to_buffer: done" );
religion.c:// #endif
religion.c:// 
religion.c:// }
religion.c:// 
religion.c:// RELIGION_WAR_DATA* religion_war_load_from_file( FILE *fp )
religion.c:// {
religion.c://     RELIGION_WAR_DATA *war, *new_war;
religion.c://     char *word;
religion.c:// 
religion.c:// #ifdef REL_DEBUG
religion.c://     log_string( "religion_war_load_from_file: start" );
religion.c:// #endif
religion.c:// 
religion.c://     war = NULL;
religion.c://     while ( TRUE )
religion.c://     {
religion.c://         word = feof( fp ) ? "End" : fread_word( fp );
religion.c:// 	if ( !strcmp(word, "War") )
religion.c:// 	{
religion.c:// 	    new_war = new_religion_war( NULL, 0 );
religion.c:// 	    new_war->opp_ID = fread_number( fp );
religion.c:// 	    new_war->status = fread_number( fp );
religion.c:// 	    new_war->next = war;
religion.c:// 	    war = new_war;
religion.c:// 	}
religion.c:// 	else if ( !strcmp(word, "End") )
religion.c:// 	    break;
religion.c:// 	else
religion.c:// 	{
religion.c:// 	    bugf( "religion_war_load_from_file: invalid match: %s", word );
religion.c:// 	    break;
religion.c:// 	}
religion.c://     }    
religion.c:// 
religion.c:// #ifdef REL_DEBUG
religion.c://     log_string( "religion_war_load_from_file: done" );
religion.c:// #endif
religion.c:// 
religion.c://     return war;
religion.c:// }
religion.c://    return religion_get_war_status(ch_fol->religion, opp_fol->religion)
religion.c://	== RELIGION_WAR_WAR
religion.c://	|| religion_get_war_status(opp_fol->religion, ch_fol->religion)
religion.c://	== RELIGION_WAR_WAR;
religion.c://    else if ( !strcmp(arg1, "war") )
religion.c://    {
religion.c://	do_religion_war( ch, argument );
religion.c://    }
religion.c://    send_to_char( "        religion war <status> <name>\n\r", ch );
religion.c:// char* war_status_name( int status )
religion.c:// {
religion.c:// 
religion.c:// #ifdef REL_DEBUG
religion.c://     log_string( "war_status_name: start" );
religion.c:// #endif
religion.c:// 
religion.c://     switch( status )
religion.c://     {
religion.c://     case RELIGION_WAR_PEACE: return "{Cpeace{x";
religion.c://     case RELIGION_WAR_WAR: return "{Rwar{x";
religion.c://     default: return "error";
religion.c://     }
religion.c:// }
religion.c:// 
religion.c:// int get_war_status_by_name( char *name )
religion.c:// {
religion.c:// 
religion.c:// #ifdef REL_DEBUG
religion.c://     log_string( "get_war_status_by_name: start" );
religion.c:// #endif
religion.c:// 
religion.c://     if ( !strcmp(name, "peace" ) )
religion.c:// 	return RELIGION_WAR_PEACE;
religion.c://     if ( !strcmp(name, "war" ) )
religion.c:// 	return RELIGION_WAR_WAR;
religion.c://     return -1; /* not found */ */
religion.c:// }
religion.c:// 
religion.c:// void do_religion_war( CHAR_DATA *ch, char *argument )
religion.c:// {
religion.c://     RELIGION_DATA *rel, *opp;
religion.c://     char arg1[MIL];
religion.c://     char buf[MSL];
religion.c://     int status,other;
religion.c:// 
religion.c:// #ifdef REL_DEBUG
religion.c://     log_string( "do_religion_war: start" );
religion.c:// #endif
religion.c:// 
religion.c://     argument = one_argument( argument, arg1 );
religion.c:// 
religion.c://     if ( !strcmp(arg1, "status") )
religion.c://     {
religion.c:// 	if ( (rel = get_religion_by_name(argument)) == NULL
religion.c:// 	     && (rel = get_religion(ch)) == NULL )
religion.c:// 	{
religion.c:// 	    send_to_char( "You must specify a valid religion.\n\r", ch );
religion.c:// 	    return;
religion.c:// 	}
religion.c:// 
religion.c:// 	sprintf( buf, "War status for %s:\tVersus %s:\n\r", rel->name, rel->name );
religion.c:// 	send_to_char( buf, ch );
religion.c:// 	for ( opp = religion_list; opp != NULL; opp = opp->next )
religion.c:// 	{
religion.c:// 	    if ( opp == rel )
religion.c:// 		continue;
religion.c:// 	    status = religion_get_war_status( rel, opp );
religion.c:// 	    other = religion_get_war_status( opp, rel );
religion.c:// 	    sprintf( buf, "%22s:    %s\t\t%s\n\r", opp->name, war_status_name(status), war_status_name(other) );
religion.c:// 	    send_to_char( buf, ch );
religion.c:// 	}
religion.c://     }
religion.c://     else if ( (status = get_war_status_by_name(arg1)) != -1 )
religion.c://     {
religion.c:// 	if ( !IS_IMMORTAL(ch) && !is_high_priest(ch) )
religion.c:// 	{
religion.c:// 	    send_to_char( "Only gods or high priests can declare war.\n\r", ch );
religion.c:// 	    return;
religion.c:// 	}
religion.c:// 
religion.c:// 	if ( (rel = get_religion(ch)) == NULL )
religion.c:// 	{
religion.c:// 	    send_to_char( "You're not even religious.\n\r", ch );
religion.c:// 	    return;
religion.c:// 	}
religion.c:// 
religion.c:// 	if ( (opp = get_religion_by_name(argument)) == NULL )
religion.c:// 	{
religion.c:// 	    send_to_char( "You must specify a valid religion.\n\r", ch );
religion.c:// 	    return;
religion.c:// 	}
religion.c:// 
religion.c:// 	if ( opp == rel )
religion.c:// 	{
religion.c:// 	    send_to_char( "You should always be at peace with yourself.\n\r", ch );
religion.c:// 	    return;
religion.c:// 	}
religion.c:// 
religion.c:// 	if ( status == religion_get_war_status(rel, opp) )
religion.c:// 	{
religion.c:// 	    send_to_char( "That wouldn't change anything.\n\r", ch );
religion.c:// 	    return;
religion.c:// 	}
religion.c:// 	
religion.c:// 	/* change the status */
religion.c:// 	religion_set_war_status( rel, opp, status );
religion.c:// 	send_to_char( "Ok.\n\r", ch );
religion.c:// 	sprintf( buf, "%s are now at %s with %s.", rel->name, arg1, opp->name );
religion.c:// 	info_message( ch, buf, TRUE );
religion.c://     }
religion.c://     else
religion.c://     {
religion.c:// 	send_to_char( "Options: status <name>\n\r", ch );
religion.c:// 	if ( IS_IMMORTAL(ch) || is_high_priest(ch) )
religion.c:// 	{
religion.c:// 	send_to_char( "         peace <name>\n\r", ch );
religion.c:// 	send_to_char( "         war <name>\n\r", ch );
religion.c:// 	}
religion.c://     }
religion.c:// 
religion.c:// #ifdef REL_DEBUG
religion.c://     log_string( "do_religion_war: done" );
religion.c:// #endif
religion.c:// 
religion.c:// }
religion.c:	case RELIGION_RANK_NEO:   // case 0:
religion.c:	    chance += 5; break;   // Total of 70% for enlighten, 80% if in temple
religion.h://typedef struct religion_data RELIGION_DATA;
religion.h://typedef struct religion_war_data RELIGION_WAR_DATA;
religion.h://typedef struct follower_data FOLLOWER_DATA;
religion.h://typedef struct religion_rank_data RELIGION_RANK_DATA;
religion.h://#define RELIGION_WAR_PEACE 0
religion.h://#define RELIGION_WAR_WAR   1
religion.h://    RELIGION_WAR_DATA *war_status;
religion.h://struct religion_war_data
religion.h://{
religion.h://    RELIGION_WAR_DATA *next;
religion.h://    RELIGION_DATA *opp;
religion.h://    int opp_ID; /* for bootup loading only */
religion.h://    int status;
religion.h://};
religion.h://void religion_save_to_file( RELIGION_DATA *religion, FILE *fp );
religion.h://int religion_get_war_status( RELIGION_DATA *religion, RELIGION_DATA *opp );
religion.h://void religion_set_war_status( RELIGION_DATA *religion, RELIGION_DATA *opp, int status );
religion.h://void religion_remove_war_status( RELIGION_DATA *religion, RELIGION_DATA *opp );
religion.h://void assign_religion_war_opp();
religion.h://RELIGION_WAR_DATA* new_religion_war( RELIGION_DATA *opp, int status );
religion.h://void free_religion_war( RELIGION_WAR_DATA *war );
religion.h://void free_religion_war_list( RELIGION_WAR_DATA *war );
religion.h://void religion_war_save_to_file( RELIGION_WAR_DATA *war, FILE *fp );
religion.h://void religion_war_save_to_buffer( RELIGION_WAR_DATA *war, DBUFFER *fp );
religion.h://RELIGION_WAR_DATA* religion_war_load_from_file( FILE *fp );
religion.h://void follower_save_to_file( FOLLOWER_DATA *list, FILE *fp );
remort.c:#define R6  32 // Astark added 12-21-12. Testing.
remort.c:#define R7  64 // Astark added 12-21-12. Testing.
remort.c:#define R8  128 // Astark added 12-22-12. Testing.
remort.c:    //purge_area( pArea );
remort.c:    //purge_area( pArea );
remort.c:    // mark as rolling stats in case we loose connection
remort.c:    // half cost of initial remort
signal.h://typedef unsigned long sigset_t;		/* at least 32 bits */
simsave.c:bool boxtemp = FALSE;//track if there are temp box files needing to be moved
simsave.c:  //DESCRIPTOR_DATA *d;
simsave.c:  //for (d = descriptor_list; d != NULL; d = d->next)
simsave.c:      }//no longer a bug
simsave.c://      log_string("load_char_obj: found in player_quit_list");
simsave.c://     log_string("load_char_obj: found in player_save_list");
simsave.c://    mem_load_storage_box( ch, mf );
skills.c:// group cost is reduced for a character if they already know skills in the group
skills.c:    // calculate sum of base costs of skills/subgroups (total and new)
skills.c:            // not a skill, so should be a subgroup
skills.c:    // safety-net against groups with total cost of 0
skills.c:    // show injury penalty
skills.c:	// show injury penalty
skills.c:			  //skill_table[i].rating[ch->class],
skills.c:    // check if further reduction is needed at all (for efficiency)
skills.c:    // mobs that cast spells via spec_fun normally can do so even while charmed
skills.c://		skill = (skill*skill_table[sn].cap[ch->class])/10;
skills.c:    if (sn != gsn_ashura) // needed to avoid infinite recursion
skills.c:        // check if skill is a stance - if so, display stance cost
smith.c:    //recursive_clone(ch,obj,clone);
stats.c:// structure for storing stat values prior to finalizing them
stats.c:    // level-based bonus
stats.c:    // level bonus
stats.c://        WAIT_STATE(ch, 2);
stats.c://        WAIT_STATE(ch, 2);
stats.c://        WAIT_STATE(ch, 2);
stats.c://    WAIT_STATE(ch, 2);
stats.c:        // sort
stats.c:// calculate min, max and current stat for die allocation
stats.c:    // gender and align tweaks
stats.c:    // get average die assigned to stat (times 100)
stats.c:    // rolled value lies between min and max, based on roll
stats.c:// assign die rolls to stats based on class and race
stats.c:// maximizes the class-weighted sum of final stats
stats.c:    // compute class factor for base stats
stats.c:    // bonus for primary/secondary stats, decreasing for higher remorts (practices get less important)
stats.c:    // bonus for int at low remort (needed for practicing skills)
stats.c:    // multiply with racial range
stats.c:    // weights for each extended stat (including body, mind, tough, speed, wit)
stats.c:    // Assign currently unassigned dice to unassigned extended attributes
stats.c:        // find highest-ranking unassigned stat
stats.c:        // assign die (unassigned dice are ordered, so we it is highest unassigned one)
stats.c:    // show total of roll
stats.c:    // "temporary" bonuses (eq/tattoos/affects with +hp/mana/move)
stats.c:    // hp
stats.c:    // mana
stats.c:    // move
stats.c:    { 1, 0, 0, 0 }, // warrior
stats.c:    { 0, 1, 0, 0 }, // thief
stats.c:    { 0, 0, 1, 0 }, // cleric
stats.c:    { 0, 0, 0, 1 }, // mage
stats.c:    { 1, 0, 0, 0 }, // gladiator
stats.c:    { 1, 0, 0, 0 }, // samurai
stats.c:    { 1, 0, 1, 0 }, // paladin
stats.c:    { 1, 1, 0, 0 }, // assassin
stats.c:    { 1, 1, 0, 0 }, // ninja
stats.c:    { 1, 0, 1, 0 }, // monk
stats.c:    { 0, 0, 1, 1 }, // templar
stats.c:    { 0, 1, 0, 1 }, // illusionist
stats.c:    { 1, 1, 0, 0 }, // gunslinger
stats.c:    { 1, 1, 0, 0 }, // ranger
stats.c:    { 0, 0, 0, 1 }  // necromancer
string.c:          //xbuf[i+2]=' ';
string.c:          //i += 3;
string.c:          //xbuf[i+3]=' ';
string.c:          //i += 4;
string.c: * Original at http://http://dark.nrg.dtu.dk/~wreck/mud/code/color.txt
tables.c://    { "infectious_arrow",  AFF_INFECTIOUS_ARROW,     TRUE  },
tables.c://    { "fervent_rage",      AFF_FERVENT_RAGE,         TRUE  },
tables.c://    { "fervent_rage_cooldown",  AFF_FERVENT_RAGE_COOLDOWN,TRUE  },
tables.c://    { "paroxysm",          AFF_PAROXYSM,             TRUE  },
tables.c://    { "paroxysm_cooldown", AFF_PAROXYSM_COOLDOWN,    TRUE  },
tables.c://    { "rupture",           AFF_RUPTURE,              TRUE  },
tables.c:	//	{   "object",   TO_OBJECT,  TRUE    },
tables.c:	//	{   "weapon",   TO_WEAPON,  TRUE    },
tables.c://  { ACHV_TATT,        1,   0,    0,     0,     0,       0,     ACHIEVE_TATT_1},
tables.c://  { ACHV_TATT,        5,   0,    0,     0,     0,       0,     ACHIEVE_TATT_2},
tables.c://  { ACHV_TATT,       13,   0,    0,     0,     0,       0,     ACHIEVE_TATT_3},
tags:!_TAG_PROGRAM_NAME	Exuberant Ctags	//
tags:!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
tags:!_TAG_PROGRAM_VERSION	5.8	//
tattoo.c:    { 10500, 500 }, // bear
tattoo.c:    { 10501, 500 }, // snake
tattoo.c:    { 10502, 500 }, // bunny
tattoo.c:    { 10503, 500 }, // tiger
tattoo.c:    { 10504, 500 }, // owl
tattoo.c:    { 10505, 500 }, // lion
tattoo.c:    { 10506, 500 }, // unicorn
tattoo.c:    { 10507, 500 }, // eagle
tattoo.c:    { 10508, 500 }, // dragon
tattoo.c:    { 10509, 500 },  // tortoise
tattoo.c:    { 10510, 2500 }, // grizzly
tattoo.c:    { 10511, 2500 }, // python
tattoo.c:    { 10512, 2500 }, // white rabbit
tattoo.c:    { 10513, 2500 }, // sabretooth tiger
tattoo.c:    { 10514, 2500 }, // fox
tattoo.c:    { 10515, 2500 }, // sphinx
tattoo.c:    { 10516, 2500 }, // elements
tattoo.c:    { 10517, 2500 }, // phoenix
tattoo.c:    { 10518, 2500 }, // greater wyrm
tattoo.c:    { 10519, 2500 }  // guarding angel
tattoo.c:    FALSE, // LIGHT
tattoo.c:    TRUE,  // WEAR_FINGER_L
tattoo.c:    TRUE,  // WEAR_FINGER_R
tattoo.c:    TRUE,  // WEAR_NECK_1
tattoo.c:    TRUE,  // WEAR_NECK_2
tattoo.c:    TRUE,  // WEAR_TORSO
tattoo.c:    TRUE,  // WEAR_HEAD
tattoo.c:    TRUE,  // WEAR_LEGS
tattoo.c:    TRUE,  // WEAR_FEET
tattoo.c:    TRUE,  // WEAR_HANDS
tattoo.c:    TRUE,  // WEAR_ARMS
tattoo.c:    FALSE, // WEAR_SHIELD
tattoo.c:    FALSE, // WEAR_ABOUT
tattoo.c:    TRUE,  // WEAR_WAIST
tattoo.c:    TRUE,  // WEAR_WRIST_L
tattoo.c:    TRUE,  // WEAR_WRIST_R
tattoo.c:    FALSE, // WEAR_WIELD
tattoo.c:    FALSE, // WEAR_HOLD
tattoo.c:    FALSE, // WEAR_FLOAT
tattoo.c:    FALSE  // WEAR_SECONDARY
tattoo.c:    // full level if no equipment worn over it
tattoo.c:    // average of level and object level for translucent equipment
tattoo.c:        // level-based bonus (only for translucent eq)
tattoo.c:        // add additional bonus (regardless of eq and level)
update.c:        // divide by 100, rounding randomly to preserve average
update.c:    // chance for restore, reaching 100% after 20-30 minutes
update.c:// spread the affect
update.c:    // may recover faster from maledictions than normal while resting
update.c:    // single check for all affects, as one skill may add multiple affects which should have same duration
update.c:            } // end of for loop
update.c:        } // end of ROOM_SAFE check
update.c:                    // apply calm effect
update.c:    static  int     pulse_save = 3; // "= 3" to reduce CPU peeks
update.c:// chance to summon best pet with beast mastery
update.c:    // safety net
update.c:    // must be in the wild for this to work
update.c:    // must be playing and not in warfare
update.c:    // only a chance to happen each tick - more likely in the forest, less likely during combat
update.c:    // must not have a pet already, and must accept them
update.c:            //MSDPSetNumber( d, eMSDP_AC, GET_AC(d->character) );
update.c:            //if ( pRoom && pRoom->vnum != d->pProtocol->pVariables[eMSDP_ROOM_VNUM]->ValueInt )
update.c:                //MSDPSetNumber( d, eMSDP_ROOM_VNUM, pRoom->vnum );
warfare.c:    // 2 hours till next automatic warfare
warfare.c:    // collect online characters elligible for warfare
warfare.c:    // compute relative probabilities for a level to be selected - eliminating single-player cases
warfare.c:    // not enough players to get a warfare going?
warfare.c:        // try again in 5 minutes
warfare.c:    // now select a level based on relative probabilities stored in player_count
warfare.c:    // safety-net
warfare.c:        // limit to 50 to prevent exploit via quest buy warfare
wizlist.c:    sprintf(buf,"{x|\\//_/%70s/_/\n\r", " ");
